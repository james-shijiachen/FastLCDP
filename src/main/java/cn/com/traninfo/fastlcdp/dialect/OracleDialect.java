package cn.com.traninfo.fastlcdp.dialect;

import cn.com.traninfo.fastlcdp.model.FieldDefinition;
import cn.com.traninfo.fastlcdp.model.IndexDefinition;
import cn.com.traninfo.fastlcdp.model.RelationDefinition;
import cn.com.traninfo.fastlcdp.model.TableDefinition;
import cn.com.traninfo.fastlcdp.enums.PrimaryKeyType;
import org.springframework.util.StringUtils;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Oracle数据库方言实现
 */
public class OracleDialect extends AbstractDatabaseDialect {
    
    @Override
    public String getIdentifierQuote() {
        return "\"";
    }
    
    @Override
    public boolean supportsIfNotExists() {
        return false; // Oracle不支持IF NOT EXISTS
    }
    
    @Override
    public String getAutoIncrementKeyword() {
        return "GENERATED BY DEFAULT AS IDENTITY";
    }
    
    @Override
    public String getCurrentTimestampFunction() {
        return "CURRENT_TIMESTAMP";
    }
    
    @Override
    public String generateCreateDatabaseSql(String databaseName, String charset, String collation) {
        // Oracle中数据库概念对应于实例，通常不需要创建
        return "-- Oracle数据库实例: " + databaseName + " (需要DBA手动创建)";
    }
    
    @Override
    public String generateDropDatabaseSql(String databaseName) {
        return "-- Oracle数据库删除需要DBA操作: " + databaseName;
    }
    
    @Override
    public String generateFieldType(FieldDefinition field) {
        String type = field.getType().toUpperCase();
        StringBuilder fieldType = new StringBuilder();
        
        switch (type) {
            // 新的通用类型映射
            case "INTEGER":
                fieldType.append("NUMBER(10)");
                break;
                
            case "LONG":
                fieldType.append("NUMBER(19)");
                break;
                
            case "DECIMAL":
                int precision = field.getPrecision() != null ? field.getPrecision() : 
                               (field.getLength() != null ? field.getLength() : 10);
                int scale = field.getScale() != null ? field.getScale() : 0;
                fieldType.append("NUMBER(").append(precision).append(",").append(scale).append(")");
                break;
                
            case "BOOLEAN":
                fieldType.append("NUMBER(1)"); // Oracle没有原生BOOLEAN类型
                break;
                
            case "CHAR":
                int charLength = field.getLength() != null ? field.getLength() : 1;
                fieldType.append("CHAR(").append(charLength).append(")");
                break;
                
            case "STRING":
                int length = field.getLength() != null ? field.getLength() : 255;
                fieldType.append("VARCHAR2(").append(length).append(")");
                break;
                
            case "TEXT":
                fieldType.append("CLOB");
                break;
                
            case "BINARY":
                fieldType.append("RAW(2000)"); // Oracle的RAW类型
                break;
                
            case "BLOB":
                fieldType.append("BLOB");
                break;
                
            case "DATETIME":
                fieldType.append("TIMESTAMP");
                break;
                
            case "JSON":
                fieldType.append("CLOB"); // Oracle 12c+支持JSON，但这里使用CLOB兼容
                break;
                
            // 保留对旧类型的兼容性支持
            case "VARCHAR":
                int varcharLength = field.getLength() != null ? field.getLength() : 255;
                fieldType.append("VARCHAR2(").append(varcharLength).append(")");
                break;
                
            case "LONGTEXT":
            case "MEDIUMTEXT":
            case "TINYTEXT":
                fieldType.append("CLOB");
                break;
                
            case "INT":
                fieldType.append("NUMBER(10)");
                break;
                
            case "BIGINT":
                fieldType.append("NUMBER(19)");
                break;
                
            case "TINYINT":
                fieldType.append("NUMBER(3)");
                break;
                
            case "SMALLINT":
                fieldType.append("NUMBER(5)");
                break;
                
            case "NUMERIC":
                int numPrecision = field.getLength() != null ? field.getLength() : 10;
                int numScale = field.getScale() != null ? field.getScale() : 0;
                fieldType.append("NUMBER(").append(numPrecision).append(",").append(numScale).append(")");
                break;
                
            case "FLOAT":
                fieldType.append("BINARY_FLOAT");
                break;
                
            case "DOUBLE":
                fieldType.append("BINARY_DOUBLE");
                break;
                
            case "BOOL":
                fieldType.append("NUMBER(1)"); // Oracle没有原生BOOLEAN类型
                break;
                
            case "DATE":
                fieldType.append("DATE");
                break;
                
            case "TIME":
                fieldType.append("TIMESTAMP"); // Oracle没有单独的TIME类型
                break;
                
            case "TIMESTAMP":
                fieldType.append("TIMESTAMP");
                break;
                
            case "LONGBLOB":
            case "MEDIUMBLOB":
            case "TINYBLOB":
                fieldType.append("BLOB");
                break;
                
            default:
                // 对于未知类型，保持原样
                fieldType.append(type);
                break;
        }
        
        return fieldType.toString();
    }
    
    @Override
    public String generateCreateTableSql(TableDefinition table) {
        StringBuilder sql = new StringBuilder();
        
        // CREATE TABLE (Oracle不支持IF NOT EXISTS)
        sql.append("CREATE TABLE ").append(escapeIdentifier(table.getName())).append(" (\n");
        
        // 字段定义
        if (table.getFields() != null && !table.getFields().isEmpty()) {
            String fieldDefinitions = table.getFields().stream()
                    .map(this::generateFieldDefinition)
                    .collect(Collectors.joining(",\n    "));
            sql.append("    ").append(fieldDefinitions);
        }
        
        // 主键定义
        List<FieldDefinition> primaryKeyFields = table.getFields().stream()
                .filter(field -> field.getPrimaryKey() != null && !PrimaryKeyType.NONE.equals(field.getPrimaryKey()))
                .collect(Collectors.toList());
        
        if (!primaryKeyFields.isEmpty()) {
            sql.append(",\n    ").append(generatePrimaryKeyDefinition(primaryKeyFields));
        }
        
        // 外键约束
        if (table.getRelations() != null && !table.getRelations().isEmpty()) {
            for (RelationDefinition relation : table.getRelations()) {
                sql.append(",\n    ").append(generateForeignKeyConstraint(relation));
            }
        }
        
        sql.append("\n)");
        
        return sql.toString();
    }
    
    @Override
    public String generateDropTableSql(String tableName) {
        return "DROP TABLE " + escapeIdentifier(tableName);
    }
    
    @Override
    public String generateTableExistsSql(String tableName) {
        return "SELECT COUNT(*) FROM user_tables WHERE table_name = " + escapeStringValue(tableName.toUpperCase());
    }
    
    @Override
    public String generateDescribeTableSql(String tableName) {
        return "SELECT column_name, data_type, nullable, data_default FROM user_tab_columns WHERE table_name = " + escapeStringValue(tableName.toUpperCase()) + " ORDER BY column_id";
    }
    
    @Override
    public String getDatabaseTypeName() {
        return "Oracle";
    }
    
    @Override
    protected String generateTableOptions(TableDefinition table) {
        // Oracle不支持ENGINE等选项，但可以添加表空间等
        return "";
    }
    
    @Override
    public String generateLimitSql(String baseSql, int offset, int limit) {
        // Oracle 12c及以上版本支持OFFSET/FETCH
        StringBuilder sql = new StringBuilder(baseSql);
        if (offset > 0) {
            sql.append(" OFFSET ").append(offset).append(" ROWS");
        }
        sql.append(" FETCH NEXT ").append(limit).append(" ROWS ONLY");
        return sql.toString();
    }
    
    @Override
    public String generateCreateSequenceSql(String sequenceName) {
        return "CREATE SEQUENCE " + escapeIdentifier(sequenceName) + 
               " START WITH 1 INCREMENT BY 1 NOCACHE";
    }
    
    @Override
    public String generateDropSequenceSql(String sequenceName) {
        return "DROP SEQUENCE " + escapeIdentifier(sequenceName);
    }
    
    @Override
    public String generateCreateIndexSql(String tableName, IndexDefinition index) {
        StringBuilder sql = new StringBuilder();
        
        // 创建索引语句开始
        sql.append("CREATE ");
        
        // 索引类型
        if ("UNIQUE".equalsIgnoreCase(index.getType())) {
            sql.append("UNIQUE ");
        }
        
        sql.append("INDEX ");
        
        // 索引名
        if (StringUtils.hasText(index.getName())) {
            sql.append(escapeIdentifier(index.getName())).append(" ");
        }
        
        // 表名
        sql.append("ON ").append(escapeIdentifier(tableName));
        
        // 索引列
        sql.append(" (");
        if (index.getColumns() != null && !index.getColumns().isEmpty()) {
            String columns = index.getColumns().stream()
                    .map(column -> {
                        StringBuilder columnDef = new StringBuilder(escapeIdentifier(column.getName()));
                        if (StringUtils.hasText(column.getOrder())) {
                            columnDef.append(" ").append(column.getOrder());
                        }
                        return columnDef.toString();
                    })
                    .collect(Collectors.joining(", "));
            sql.append(columns);
        }
        sql.append(")");
        
        return sql.toString();
    }
    
    @Override
    public String generateFieldDefinition(FieldDefinition field) {
        StringBuilder sql = new StringBuilder();
        
        // 字段名
        sql.append(escapeIdentifier(field.getName()));
        
        // 字段类型
        sql.append(" ").append(generateFieldType(field));
        
        // 自增（Oracle使用IDENTITY列）
        if (PrimaryKeyType.AUTO_INCREMENT.equals(field.getPrimaryKey())) {
            sql.append(" ").append(getAutoIncrementKeyword());
        }
        
        // 是否允许为空
        if (field.getNullable() != null && !field.getNullable()) {
            sql.append(" NOT NULL");
        }
        
        // 默认值
        if (StringUtils.hasText(field.getDefaultValue()) && 
            (!PrimaryKeyType.AUTO_INCREMENT.equals(field.getPrimaryKey()))) {
            sql.append(" DEFAULT ");
            if (field.getDefaultValue().equalsIgnoreCase("CURRENT_TIMESTAMP") ||
                field.getDefaultValue().equalsIgnoreCase("NOW()")) {
                sql.append(getCurrentTimestampFunction());
            } else if (field.getDefaultValue().startsWith("'") && field.getDefaultValue().endsWith("'")) {
                sql.append(field.getDefaultValue());
            } else {
                sql.append(escapeStringValue(field.getDefaultValue()));
            }
        }
        
        return sql.toString();
    }
}